{"version":3,"sources":["webpack:///./node_modules/engine.io-parser/lib/browser.js","webpack:///./node_modules/engine.io-parser/lib/keys.js","webpack:///./node_modules/engine.io-parser/lib/utf8.js"],"names":["base64encoder","keys","hasBinary","sliceBuffer","after","utf8","ArrayBuffer","isAndroid","navigator","test","userAgent","isPhantomJS","dontSendBlobs","exports","protocol","packets","open","close","ping","pong","message","upgrade","noop","packetslist","err","type","data","Blob","encodeBase64Object","packet","callback","encodeArrayBuffer","supportsBinary","encodeBase64Packet","contentArray","Uint8Array","resultBuffer","byteLength","i","length","buffer","encodeBlobAsArrayBuffer","fr","FileReader","onload","encodePacket","result","readAsArrayBuffer","encodeBlob","blob","tryDecode","decode","strict","e","map","ary","each","done","Array","next","eachWithIndex","el","cb","error","msg","utf8encode","undefined","base64","encoded","encode","String","b64data","b64","split","readAsDataURL","fromCharCode","apply","typed","basic","btoa","decodePacket","binaryType","utf8decode","charAt","decodeBase64Packet","substr","Number","substring","asArray","rest","encodePayload","isBinary","encodePayloadAsBlob","encodePayloadAsArrayBuffer","setLengthHeader","encodeOne","doneCallback","results","join","decodePayload","decodePayloadAsBinary","n","l","chr","ret","encodedPackets","totalLength","reduce","acc","p","len","toString","resultArray","bufferIndex","forEach","isString","ab","view","charCodeAt","lenStr","parseInt","binaryIdentifier","size","lengthAry","bufferTail","buffers","tailArray","msgLength","push","total","module","Object","obj","arr","has","prototype","hasOwnProperty","call","byteArray","byteCount","byteIndex","stringFromCharCode","ucs2decode","string","value","extra","output","counter","ucs2encode","array","index","checkScalarValue","codePoint","Error","toUpperCase","createByte","shift","encodeCodePoint","symbol","opts","codePoints","byteString","readContinuationByte","continuationByte","decodeSymbol","byte1","byte2","byte3","byte4","tmp","version"],"mappings":"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","file":"js/yarn.engine.io-parser.500a917d.js","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary2');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('./utf8');\n\nvar base64encoder;\nif (typeof ArrayBuffer !== 'undefined') {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data === 'string') {\n    if (data.charAt(0) === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var ret = callback(packet, i + n, l);\n      if (false === ret) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] === 255) break;\n\n      // 310 = char length of Number.MAX_VALUE\n      if (msgLength.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n","\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n","/*! https://mths.be/utf8js v2.1.2 by @mathias */\n\nvar stringFromCharCode = String.fromCharCode;\n\n// Taken from https://mths.be/punycode\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\tvar value;\n\tvar extra;\n\twhile (counter < length) {\n\t\tvalue = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// high surrogate, and there is a next character\n\t\t\textra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n// Taken from https://mths.be/punycode\nfunction ucs2encode(array) {\n\tvar length = array.length;\n\tvar index = -1;\n\tvar value;\n\tvar output = '';\n\twhile (++index < length) {\n\t\tvalue = array[index];\n\t\tif (value > 0xFFFF) {\n\t\t\tvalue -= 0x10000;\n\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(value);\n\t}\n\treturn output;\n}\n\nfunction checkScalarValue(codePoint, strict) {\n\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\tif (strict) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n/*--------------------------------------------------------------------------*/\n\nfunction createByte(codePoint, shift) {\n\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n}\n\nfunction encodeCodePoint(codePoint, strict) {\n\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\treturn stringFromCharCode(codePoint);\n\t}\n\tvar symbol = '';\n\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t}\n\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\tif (!checkScalarValue(codePoint, strict)) {\n\t\t\tcodePoint = 0xFFFD;\n\t\t}\n\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\tsymbol += createByte(codePoint, 6);\n\t}\n\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\tsymbol += createByte(codePoint, 12);\n\t\tsymbol += createByte(codePoint, 6);\n\t}\n\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\treturn symbol;\n}\n\nfunction utf8encode(string, opts) {\n\topts = opts || {};\n\tvar strict = false !== opts.strict;\n\n\tvar codePoints = ucs2decode(string);\n\tvar length = codePoints.length;\n\tvar index = -1;\n\tvar codePoint;\n\tvar byteString = '';\n\twhile (++index < length) {\n\t\tcodePoint = codePoints[index];\n\t\tbyteString += encodeCodePoint(codePoint, strict);\n\t}\n\treturn byteString;\n}\n\n/*--------------------------------------------------------------------------*/\n\nfunction readContinuationByte() {\n\tif (byteIndex >= byteCount) {\n\t\tthrow Error('Invalid byte index');\n\t}\n\n\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\tbyteIndex++;\n\n\tif ((continuationByte & 0xC0) == 0x80) {\n\t\treturn continuationByte & 0x3F;\n\t}\n\n\t// If we end up here, itâ€™s not a continuation byte\n\tthrow Error('Invalid continuation byte');\n}\n\nfunction decodeSymbol(strict) {\n\tvar byte1;\n\tvar byte2;\n\tvar byte3;\n\tvar byte4;\n\tvar codePoint;\n\n\tif (byteIndex > byteCount) {\n\t\tthrow Error('Invalid byte index');\n\t}\n\n\tif (byteIndex == byteCount) {\n\t\treturn false;\n\t}\n\n\t// Read first byte\n\tbyte1 = byteArray[byteIndex] & 0xFF;\n\tbyteIndex++;\n\n\t// 1-byte sequence (no continuation bytes)\n\tif ((byte1 & 0x80) == 0) {\n\t\treturn byte1;\n\t}\n\n\t// 2-byte sequence\n\tif ((byte1 & 0xE0) == 0xC0) {\n\t\tbyte2 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\tif (codePoint >= 0x80) {\n\t\t\treturn codePoint;\n\t\t} else {\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t}\n\n\t// 3-byte sequence (may include unpaired surrogates)\n\tif ((byte1 & 0xF0) == 0xE0) {\n\t\tbyte2 = readContinuationByte();\n\t\tbyte3 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\tif (codePoint >= 0x0800) {\n\t\t\treturn checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n\t\t} else {\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t}\n\n\t// 4-byte sequence\n\tif ((byte1 & 0xF8) == 0xF0) {\n\t\tbyte2 = readContinuationByte();\n\t\tbyte3 = readContinuationByte();\n\t\tbyte4 = readContinuationByte();\n\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t(byte3 << 0x06) | byte4;\n\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\treturn codePoint;\n\t\t}\n\t}\n\n\tthrow Error('Invalid UTF-8 detected');\n}\n\nvar byteArray;\nvar byteCount;\nvar byteIndex;\nfunction utf8decode(byteString, opts) {\n\topts = opts || {};\n\tvar strict = false !== opts.strict;\n\n\tbyteArray = ucs2decode(byteString);\n\tbyteCount = byteArray.length;\n\tbyteIndex = 0;\n\tvar codePoints = [];\n\tvar tmp;\n\twhile ((tmp = decodeSymbol(strict)) !== false) {\n\t\tcodePoints.push(tmp);\n\t}\n\treturn ucs2encode(codePoints);\n}\n\nmodule.exports = {\n\tversion: '2.1.2',\n\tencode: utf8encode,\n\tdecode: utf8decode\n};\n"],"sourceRoot":""}